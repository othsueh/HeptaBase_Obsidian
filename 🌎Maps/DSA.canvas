{
	"nodes":[
		{"type":"text","text":"# 資料元素\n> 組成資料的，有一定意義的基本單位","id":"e7fcbfd110759e20","x":-1567,"y":-254,"width":303,"height":139},
		{"type":"text","text":"# 資料結構\n> 資料元素間相互存在的一種或多種特定關係的集合","id":"63aa6b8a3c715c04","x":-1567,"y":105,"width":332,"height":149},
		{"type":"text","text":"# 邏輯結構\n> 資料中資料元素間的關係\n\n- 集合\n- 線性結構\n- 樹狀結構\n- 圖形結構","id":"2d7e7d2d305d2470","x":-1127,"y":-83,"width":367,"height":263},
		{"type":"text","text":"# 物理結構\n> 資料的邏輯結構在電腦中的儲存形式\n\n- 循序儲存\n- 鏈式儲存","id":"9ee6dceb11279792","x":-1127,"y":225,"width":367,"height":180},
		{"type":"text","text":"# 資料物件（資料）\n> 性質相同資料元素的集合，資料的子集","id":"967baf299200541c","x":-1567,"y":-90,"width":310,"height":139},
		{"type":"text","text":"# 資料類型\n- 原子類型：不可再分割的基本類型\n- 結構類型：可再進行分割的資料元素集合","id":"50032639b13e9772","x":-2047,"y":-101,"width":380,"height":150},
		{"type":"text","text":"# 集合\n> 資料元素同存在一個集合中，之間沒有任何關係","id":"d524c114663e28ce","x":-627,"y":-440,"width":400,"height":139},
		{"type":"text","text":"# 線性結構\n> 資料元素間的關係為一對一的關係","id":"b045a22ab288128e","x":-627,"y":-230,"width":280,"height":147},
		{"type":"text","text":"# 樹形結構\n> 資料元素間的關係為一對多的關係","id":"058b4fe8515d182e","x":-627,"y":-19,"width":291,"height":135},
		{"type":"text","text":"# 圖形結構\n> 資料元素間具有多對多的關係","id":"93fdee4cab32de39","x":-627,"y":180,"width":300,"height":97},
		{"type":"text","text":"# 循序儲存結構\n> 把資料元素儲存在位址連續的儲存單元裡\n\n**物理結構與邏輯結構一致**","id":"cda110c80e25704a","x":-615,"y":308,"width":288,"height":194},
		{"type":"text","text":"# 鏈式儲存結構\n> 資料元素不一定要儲存在位址連續的儲存單元裡，可以分散。\n\n**指標** ： 儲存有關聯資料元素的位址","id":"82fea4bbc823eae0","x":-615,"y":525,"width":380,"height":175},
		{"type":"text","text":"# 演算法\n> 解決特定問題的求解步驟與方法","id":"4325eda2aa527a4d","x":-8,"y":-145,"width":300,"height":120},
		{"type":"text","text":"# 有限性\n> 演算法在執行有限的步驟後會自動停止，不進入無窮迴圈。且每個步驟都在可接受時間內完成。","id":"60652b8a79ffd330","x":352,"y":-25,"width":337,"height":167},
		{"type":"text","text":"# 演算法的特性\n- 輸入\n- 輸出\n- 有限性\n- 確定性\n- 可行性","id":"1df558545160644b","x":-8,"y":15,"width":260,"height":239},
		{"type":"text","text":"# 確定性\n> 演算法的每一個步驟有明確的含義，沒有不確定性","id":"fd31dc68220e23ce","x":352,"y":175,"width":320,"height":121},
		{"type":"text","text":"# 可行性\n> 演算法的每一步都是可行的，每一步都可以在有限時間內完成","id":"6df5252c7ac50774","x":347,"y":341,"width":325,"height":134},
		{"type":"text","text":"# deque\nlibrary : `<deque>`\n\n`deque<type> va` : create an empty deque of `type`\n`front()` : get the first element of the deque\n`back()` : get the last element of the deque\n`pop_back()` : remove the last element\n`push_back()` : add an element behind last element\n`at(pos)` : get the element at the `pos` position\n`insert(pos,va)` : insert `va` at the `pos` position\n`erase(pos)` :  remove element at the `pos` position\n`begin()` : get the first element's memory locate, often used with `end()` in a loop\n`empty()` : return if the deque is empty\n`clear()` : clean the deque until it's empty\n","id":"e0edc34a4d88a380","x":-1489,"y":700,"width":465,"height":590},
		{"type":"text","text":"# C++ STL : stack\n### What's stack\nstack has the property of FILO (First in Last out).\n![[Pasted image 20230816161724.png]]\n*plate in the bottom must be the first in of this stack.*\n\n### Where to get this tool \n`<stack>`\n### How to declare it\n`stack<type> stk` \ncreate an empty stack `stk`  of `type`\n\n### Methods\n| **Put Element** | **Get Element**                               | **Delete Element** | **Get Size** |\n|:---------------:|:---------------------------------------------:|:------------------:|:------------:|\n| `stk.push(x)`   | `stk.pop()`| `stk.top()`        | `stk.size()` |  \n\n|  **Check Empty** |\n|:-----------------:|\n|  `stk.empty()`   |  \n\n### Example\n**Four arithmetic operations**\n1. get input string, declare two stacks, one for operators, one for operands.\n2. get arithmetic unit from the end of the string. **If from beginning, the result will face 3  - 3\\*3 =0 situation**\n3. \n\t1. If the unit is digit, then store it in the operands. I use `digit` to check if unit is single digit or not.\n\t2. Else the unit is operator, then store it in the operators.\n4. When face meet ( or final clean stack situation, I will start to calculate, Get 1 operator and 2 operands from both stacks. \n5. Situation * and /, push the result of 2 operands into stack.\n6. Situation + and -, check if operators is empty first then check top of operators has * or /\n\t1. If true, then change the order of operators, let + or - at * or / 's  back. And change the order of operands, 1 2 3 becomes 2 3 1\n\t2. Else push the result of 2 operands into stack.\n```cpp\n#include <iostream>\n#include <stack>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nint main()\n{\n    string str;\n    getline(cin,str);\n    stack <char> operators;\n    stack <int> operands;\n    int digit = 0;\n    for(int i = str.length(); i >= 0; i--){\n        (i==str.length()) ? --i : i;\n        char c = str[i];\n        if(isdigit(c)){\n            int operand = 0;\n            if(digit == 0){\n                operand = c - '0';\n                ++digit;\n            }else{\n                operand = operands.top() + (c - '0')*(pow(10,digit)); \n                operands.pop();\n                ++digit;\n            }\n            operands.push(operand);\n        }else{\n            digit = 0;\n            if(c == '+' || c == '-' || c == '*' || c=='/') operators.push(c);\n            else if(c == ')') operators.push(c);\n            else if(c == '('){\n                while(operators.top() != ')'){\n                    char cp = operators.top();\n                    operators.pop();\n                    int op1 = operands.top();\n                    operands.pop();\n                    int op2 = operands.top();\n                    operands.pop();\n                    switch(cp){\n                        case '+':\n                            if(!operators.empty() &&(operators.top() == '*' || operators.top() == '/')){\n                                char cp2 = operators.top();\n                                operators.pop();\n                                operators.push(cp);\n                                operators.push(cp2);\n                                int op3 = operands.top();\n                                operands.pop();\n                                operands.push(op1);\n                                operands.push(op3);\n                                operands.push(op2);\n                            }\n                            else operands.push(op1 + op2);\n                            break;\n                        case '-':\n                            if(!operators.empty() &&(operators.top() == '*' || operators.top() == '/')){\n                                char cp2 = operators.top();\n                                operators.pop();\n                                operators.push(cp);\n                                operators.push(cp2);\n                                int op3 = operands.top();\n                                operands.pop();\n                                operands.push(op1);\n                                operands.push(op3);\n                                operands.push(op2);\n                            }\n                            else operands.push(op1 - op2);\n                            break;\n                        case '*':\n                            operands.push(op1 * op2);\n                            break;\n                        case '/':\n                            operands.push(op1 / op2);\n                            break;\n                        default:\n                            break;\n                    }\n                }\n                operators.pop();\n        }  \n        }}\n        while(!operators.empty()){\n            char cp = operators.top();\n            operators.pop();\n            int op1 = operands.top();\n            operands.pop();\n            int op2 = operands.top();\n            operands.pop();\n            switch(cp){\n                case '+':\n                    if(!operators.empty() &&(operators.top() == '*' || operators.top() == '/')){\n                        char cp2 = operators.top();\n                        operators.pop();\n                        operators.push(cp);\n                        operators.push(cp2);\n                        int op3 = operands.top();\n                        operands.pop();\n                        operands.push(op1);\n                        operands.push(op3);\n                        operands.push(op2);\n                    }\n                    else operands.push(op1 + op2);\n                    break;\n                case '-':\n                    if(!operators.empty() &&(operators.top() == '*' || operators.top() == '/')){\n                        char cp2 = operators.top();\n                        operators.pop();\n                        operators.push(cp);\n                        operators.push(cp2);\n                        int op3 = operands.top();\n                        operands.pop();\n                        operands.push(op1);\n                        operands.push(op3);\n                        operands.push(op2);\n                    }\n                    else operands.push(op1 - op2);\n                    break;\n                case '*':\n                    operands.push(op1 * op2);\n                    break;\n                case '/':\n                    operands.push(op1 / op2);\n                    break;\n                default:\n                    break;\n            }\n        }\n    cout << operands.top() << '\\n';\n}\n```\n","id":"bd4443ae9cada375","x":-4160,"y":-20,"width":1197,"height":4686},
		{"id":"041f46c1f43c1fb9","x":-2780,"y":-20,"width":578,"height":594,"type":"text","text":"# C++ STL : vector\n### What's vector\nDynamic array. More useful than array, but reduce the performance.\n\n### Where to get this tool\n`<vector>`\n\n### How to declare it\n`vector<type> vcr`\ncreate an empty vector `vcr` of `type`.\n\n`vector<type> vcr(2,0)`\ncreate a vector with 2 * 1 table.\n\n`vector<vector<type>> vcr(2,vector<type>(10,0))`\ncreate a dimensional vector with 2 * 10 table."}
	],
	"edges":[
		{"id":"c76f581c3c10f47e","fromNode":"2d7e7d2d305d2470","fromSide":"left","toNode":"63aa6b8a3c715c04","toSide":"right"},
		{"id":"b6c9574bc918ae4e","fromNode":"9ee6dceb11279792","fromSide":"left","toNode":"63aa6b8a3c715c04","toSide":"right"},
		{"id":"c31da3e41929068e","fromNode":"d524c114663e28ce","fromSide":"left","toNode":"2d7e7d2d305d2470","toSide":"right"},
		{"id":"39e6e547a88dbb15","fromNode":"b045a22ab288128e","fromSide":"left","toNode":"2d7e7d2d305d2470","toSide":"right"},
		{"id":"4b22dbc222bf03f1","fromNode":"058b4fe8515d182e","fromSide":"left","toNode":"2d7e7d2d305d2470","toSide":"right"},
		{"id":"686f0af635d251e4","fromNode":"93fdee4cab32de39","fromSide":"left","toNode":"2d7e7d2d305d2470","toSide":"right"},
		{"id":"92004dcc85a779eb","fromNode":"9ee6dceb11279792","fromSide":"right","toNode":"cda110c80e25704a","toSide":"left"},
		{"id":"e866d04451d99e32","fromNode":"9ee6dceb11279792","fromSide":"right","toNode":"82fea4bbc823eae0","toSide":"left"},
		{"id":"d1a5848a768cf197","fromNode":"967baf299200541c","fromSide":"top","toNode":"e7fcbfd110759e20","toSide":"bottom"},
		{"id":"3cae864cb256359b","fromNode":"967baf299200541c","fromSide":"bottom","toNode":"63aa6b8a3c715c04","toSide":"top"},
		{"id":"773958f4faa7c82a","fromNode":"50032639b13e9772","fromSide":"right","toNode":"e7fcbfd110759e20","toSide":"left"},
		{"id":"3087f09cda82b42c","fromNode":"50032639b13e9772","fromSide":"right","toNode":"63aa6b8a3c715c04","toSide":"left"},
		{"id":"00546dca22eac9c5","fromNode":"4325eda2aa527a4d","fromSide":"bottom","toNode":"1df558545160644b","toSide":"top"},
		{"id":"c418677b4f4aa257","fromNode":"1df558545160644b","fromSide":"right","toNode":"60652b8a79ffd330","toSide":"left"},
		{"id":"c0a062181406878c","fromNode":"1df558545160644b","fromSide":"right","toNode":"fd31dc68220e23ce","toSide":"left"},
		{"id":"343befc5148b92a5","fromNode":"1df558545160644b","fromSide":"right","toNode":"6df5252c7ac50774","toSide":"left"}
	]
}